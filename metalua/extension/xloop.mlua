-------------------------------------------------------------------------------
-- Copyright (c) 2006-2013 Fabien Fleutot and others.
--
-- All rights reserved.
--
-- This program and the accompanying materials are made available
-- under the terms of the Eclipse Public License v1.0 which
-- accompanies this distribution, and is available at
-- http://www.eclipse.org/legal/epl-v10.html
--
-- This program and the accompanying materials are also made available
-- under the terms of the MIT public license which accompanies this
-- distribution, and is available at http://www.lua.org/license.html
--
-- Contributors:
--     Fabien Fleutot - API and implementation
--
-------------------------------------------------------------------------------
-- Loop control syntax extensions
--
-- * Allows to compound loop headers together, e.g. write:
--      for i=1,10 for j=1,10 do f(i,j) end
--   instead of:
--      for i=1,10 do for j=1,10 do f(i,j) end end
--   loop headers are "for/=" and "for/in"
--
-- * while <condition> in a loop header will break the loop(s)
--   as soon as condition stops being satisfied.
--
-- * until <condition> in a loop header will break the loop(s)
--   as soon as condition is satisfied.
--
-- * if <condition> in a loop header will skip an iteration
--   if the condition is not satisfied.
--
-- TODO: document ordering matters, e.g. how
-- "for i in x() if cond(i) for j in y()" is parsed.
-- TODO: merge with metalua.extension.comprehension
--
-------------------------------------------------------------------------------

-{ extension ('match', ...) }

local Q   = require 'metalua.treequery'
local gg  = require 'metalua.grammar.generator'

-------------------------------------------------------------------------------
-- Back-end: Recompose the loop
local function loop_builder(x)
   local first, elements, body = unpack(x)

   -------------------------------------------------------------------
   -- If it's a regular loop, don't bloat the code
   if not next(elements) then
      table.insert(first, body)
      return first
   end

   -------------------------------------------------------------------
   -- There's no reason to treat the first element in a special way
   table.insert(elements, 1, first)

   -------------------------------------------------------------------
   -- Change breaks into gotos that escape all loops at once.
   local exit_label = nil
   local function break_to_goto(break_node)
       if not exit_label then exit_label = gg.gensym 'break' [1] end
       break_node.tag = 'Goto'
       break_node[1] = exit_label
   end
   Q(body)
       :not_under('Function', 'Forin', 'Fornum', 'While', 'Repeat')
       :filter('Break')
       :foreach (break_to_goto)

   -------------------------------------------------------------------
   -- Compile all headers elements, from last to first
   for i = #elements, 1, -1 do
      local e = elements[i]
      match e with
      | `If{ cond }    ->
         body = `If{ cond, {body} }
      | `Until{ cond } ->
         body = +{stat: if -{cond} then -{exit()} else -{body} end }
      | `Forin{ ... } | `Fornum{ ... } ->
         table.insert (e, {body}); body=e
      end
   end

   -------------------------------------------------------------------
   -- If some breaks had to be changed into gotos, insert the label
   if exit_label then body = { body, `Label{ exit_label } } end
   return body
end

----------------------------------------------------------------------
-- Syntax modifier

return function(M)
    local _M= gg.future(M)
    local original_for_header = M.for_header
    M.stat :del  'for'
    M.stat :del  'while'

    M.loop_suffix = gg.multisequence{
        { 'while',  _M.expr, builder = |x| `Until{ `Op{ 'not', x[1] } } },
        { 'until',  _M.expr, builder = |x| `Until{ x[1] } },
        { 'if',     _M.expr, builder = |x| `If{ x[1] } },
        { 'for',    original_for_header, builder = |x| x[1] } }

    M.loop_suffix_list = gg.list{ _M.loop_suffix, terminators='do' }

    M.stat :add{
        'for', original_for_header, _M.loop_suffix_list, 'do', _M.block, 'end',
        builder = loop_builder }

    M.stat :add{
        'while', _M.expr, _M.loop_suffix_list, 'do', _M.block, 'end',
        builder = |x| loop_builder{ `While{x[1]}, x[2], x[3] } }
end